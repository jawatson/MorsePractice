package org.minow.MorsePractice;import java.awt.Color;import java.awt.event.*;import java.awt.datatransfer.*;         /* Clipboard    */import java.io.IOException;import javax.swing.event.DocumentEvent;import javax.swing.event.DocumentListener;import javax.swing.JMenuItem;import javax.swing.JTextArea;/** * An EditTextArea is a TextArea component that understands how to control the * Edit Menu Cut, Copy, and Paste and Undo options. It supports the * standard TextArea constructors with an additional EditTextAreaListener * parameter. It also supports the following methods: * <TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0"> *  <TR> *   <TD><CODE>setEditTextAreaListener(listener)</CODE></TD> *   <TD>Designate a listener (designate null to remove the listener).</TD> *  </TR> *  <TR> *   <TD><CODE>getEditTextAreaListener()</CODE></TD> *   <TD>Return the current listener.</TD> *  </TR> *  <TR> *   <TD><CODE>cutClipboardContents()</CODE></TD> *   <TD>Respond to Edit/Cut menu commands.</TD> *  </TR> *  <TR> *   <TD><CODE>copyClipboardContents()</CODE></TD> *   <TD>Respond to Edit/Copy menu commands</TD> *  </TR> *  <TR> *   <TD><CODE>pasteClipboardContents()</CODE></TD> *   <TD>Respond to Edit/Paste menu commands</TD> *  </TR> *  <TR> *   <TD><CODE>clearSelection()</CODE></TD> *   <TD>Respond to Edit/Clear menu commands</TD> *  </TR> *  <TR> *   <TD><CODE>replaceSelection(String text)</CODE></TD> *   <TD>For search/replace support</TD> *  </TR> *  <TR> *   <TD><CODE>performUndo()</CODE></TD> *   <TD>Respond to Edit/Undo menu commands<TD> *  </TR> * </TABLE> * EditTestArea only implements one level of undo. This could easily be * extended for multiple undo, however. * * <p> * Copyright &copy; 1999-2000  *      <a href="mailto:minow@pobox.com">Martin Minow</a>. *      All Rights Reserved. * </p> * <p> * <small> * Permission to use, copy, modify, and redistribute this software and its * documentation for personal, non-commercial use is hereby granted provided that * this copyright notice and appropriate documentation appears in all copies. This * software may not be distributed for fee or as part of commercial, "shareware," * and/or not-for-profit endevors including, but not limited to, CD-ROM collections, * online databases, and subscription services without specific license.  The * author makes no expressed or implied warranty of any kind and assumes no * responsibility for errors or omissions. No liability is assumed for any incidental * or consequental damages in connection with or arising out of the use of the * information or program. * </small> * </p> * * @author <a href="mailto:minow@pobox.com">Martin Minow</a> * @version 1.1 * This application is Java 1.1 compatible. */public class EditTextArea extends JTextArea        implements      FocusListener,          /* Which text field gets edited */                        DocumentListener,           /* To enable edit menu items    */                        KeyListener,            /* To enable edit menu items    */                        MouseListener           /* To enable edit menu items    */{
    public static final long serialVersionUID = 13040901L;    /**     * The listener will be notified when the edit menu needs adjusting.     */    private EditTextAreaListener listener       = null;    /**     * The activeTextArea is null if this TextArea is inactive, and     * will be equal to "this" if this area has the focus.     */    private EditTextArea activeTextArea         = null;    /**     * currentHasSelection, currentHasClipboardContent, and currentUndoState     * shadow the current state so the listener isn't called unnecessarily.     */    private boolean currentHasSelection         = false;    private boolean currentHasClipboardContent  = false;    private int currentUndoState                = EditTextAreaListener.UNDO_UNDEFINED;    /*     * These variables manage the Undo state.     */    private int         undoState               = EditTextAreaListener.UNDO_NOTHING;    private String      undoText                = "";    private int         previousSelectionStart  = 0;    private int         beforeSelectionStart    = 0;    private int         beforeSelectionEnd      = 0;    private Transferable undoClipboard          = null;        /**     * Create an EditTextArea with a defined listener     * @param listener                  The desired listener     */    public EditTextArea(            EditTextAreaListener        listener        )    {        super();        setEditable(true);        setLineWrap(true);        setWrapStyleWord(true);        setEditTextAreaListener(listener);    }    /**     * Create an EditTextArea with a defined listener     * @param text                      The TextArea initial content     * @param listener                  The desired listener     */    public EditTextArea(            String                      text,            EditTextAreaListener        listener        )    {        super(text);        setEditable(true);        setLineWrap(true);        setWrapStyleWord(true);        setEditTextAreaListener(listener);    }    /**     * Create an EditTextArea with a defined listener     * @param rows                      The number of rows of content     * @param cols                      The width of the TextArea     * @param listener                  The desired listener     */    public EditTextArea(            int                         rows,            int                         cols,            EditTextAreaListener        listener        )    {        super(rows, cols);        setEditable(true);        setLineWrap(true);        setWrapStyleWord(true);        setEditTextAreaListener(listener);    }    /**     * Create an EditTextArea with a defined listener     * @param text                      The TextArea initial content     * @param rows                      The number of rows of content     * @param cols                      The width of the TextArea     * @param listener                  The desired listener     */    public EditTextArea(            String                      text,            int                         rows,            int                         cols,            EditTextAreaListener        listener        )    {        super(text, rows, cols);        setEditable(true);        setLineWrap(true);        setWrapStyleWord(true);        setEditTextAreaListener(listener);    }    /**     * Create an EditTextArea with a defined listener     * @param text                      The TextArea initial content     * @param rows                      The number of rows of content     * @param cols                      The width of the TextArea     * @param scrollBarVis              Scrollbar visibility configuration     * @param listener                  The desired listener     */    public EditTextArea(            String                      text,            int                         rows,            int                         cols,            int                         vertScrollBarPolicy,            int				horzScrollBarPolicy,            EditTextAreaListener        listener        )    {        //super(text, rows, cols, scrollBarVis); //todo add the scrollpane policy.        super(text, rows, cols);        setEditable(true);        setLineWrap(true);        setWrapStyleWord(true);        setEditTextAreaListener(listener);    }    /**     * setEditTextListener records the Component that is interested in     * edit events.     * @param listener  The component that will be notified when     *                  the edit menu may need adjusting.     */    public synchronized void setEditTextAreaListener(EditTextAreaListener listener) {        this.listener                   = listener;        if (listener == null) {            removeKeyListener(this);            getDocument().removeDocumentListener(this);            removeMouseListener(this);            enableEditMenu(null, true);        }        else {            addKeyListener(this);            addFocusListener(this);            getDocument().addDocumentListener(this);            addMouseListener(this);            enableEditMenu(activeTextArea, true);        }    }    /**     * Retrieve the current listener     * @return the listener or null if none.     */    public EditTextAreaListener getEditTextAreaListener()    {        return (listener);    }    /**     * Configure the Edit/Undo menu item. Note that this is     * a static method. Note that this method should be     * replaced by a localized variant.     * @param editTextArea      The active text area (may be null)     * @param miUndo            The Undo menu item.     */    public static void setUndoMenuItem(            EditTextArea        editTextArea,            JMenuItem            miUndo        )    {        if (editTextArea != null) {            editTextArea.setUndoMenuItem(miUndo);        }        else {            miUndo.setText(                EditTextAreaListener.undoMenuLabels[                        EditTextAreaListener.UNDO_NOTHING                    ]);            miUndo.setEnabled(false);        }    }    /**     * Configure the Edit/Undo menu item for this (active)     * EditTextArea     * @param miUndo            The Undo menu item.     */    public void setUndoMenuItem(            JMenuItem            miUndo        )    {        miUndo.setText(getUndoMenuItemLabel());        miUndo.setEnabled(isUndoMenuItemEnabled());    }    /**     * Return the string that should be displayed in the Edit/Undo     * menu item for this EditTextArea. This uses the default     * strings defined in EditTextAreaListener: it should be     * modified for localization.     * @return the appropriate label string     */    public String getUndoMenuItemLabel()    {        return (EditTextAreaListener.undoMenuLabels[undoState]);    }    /**     * Return the Edit/Undo menu item enable state. Return true     * if the menu item should be enabled, false if disabled.     * @return true if the Undo MenuItem should be enabled.     */    public boolean isUndoMenuItemEnabled()    {        boolean result          = false;        switch (undoState) {        case EditTextAreaListener.UNDO_UNDEFINED:        case EditTextAreaListener.UNDO_NOTHING:        case EditTextAreaListener.REDO_NOTHING:            result              = false;            break;        default:            result              = true;            break;        }        return (result);    }    /**     * When the Component that owns the menubar receives an <Edit/Cut>     * command, it calls cutClipboardContents to cut the selection     * from this TextArea to the clipboard.     */    public void cutClipboardContents()    {        saveUndoState(EditTextAreaListener.UNDO_CUT);        copyClipboardContents();        replaceRange("", getSelectionStart(), getSelectionEnd());    }    /**     * When the Component that owns the menubar receives an <Edit/Copy>     * command, it calls copyClipboardContents to copy the selection     * from this TextArea to the clipboard. This cannot be undone.     */    public void copyClipboardContents()    {        putClipboard(getSelectedText());    }    /**     * When the Component that owns the menubar receives an <Edit/Paste>     * command, it calls pasteClipboardContents to copy the Clipboard     * to this TextArea.     * @return true if the paste was successful.     */    public boolean pasteClipboardContents()    {        boolean success         = isClipboardString();        if (success) {            saveUndoState(EditTextAreaListener.UNDO_PASTE);            setBackground(Color.white);            setForeground(Color.black);            replaceRange(                    getClipboard(),                    getSelectionStart(),                    getSelectionEnd()                );        }        return (success);    }    /**     * When the Component that owns the menubar receives an <Edit/Clear>     * command, it calls clearSelection to discard the current     * TextArea selection.     */    public void clearSelection()    {        saveUndoState(EditTextAreaListener.UNDO_CLEAR);        replaceRange("", getSelectionStart(), getSelectionEnd());    }    /**     * To implement search/replace, the caller designates the     * are to be replaced by executing setSelectionStart() and     * setSelectionEnd(), then calling replaceSelection.     * @param text              The replacement text     */    public void replaceSelection(            String              text        )    {        saveUndoState(EditTextAreaListener.UNDO_REPLACE);        replaceRange(text, getSelectionStart(), getSelectionEnd());    }    /*     * Implement the FocusListener interface.     * This method is called when the TextArea gains focus.     * @param event             The FocusEvent     */    public void focusGained(            FocusEvent          event        )    {        enableEditMenu(this, true);    }    /*     * Implement the FocusListener interface.     * This method is called when the TextArea loses focus.     * @param event             The FocusEvent     */    public void focusLost(           FocusEvent           event        )    {        enableEditMenu(null, false);    }    /**     * Implement the TextListener interface.     * This method is called when text changes.     * @param event             The DocumentEvent     */    public void textValueChanged(DocumentEvent event) {        enableEditMenu(activeTextArea, false);        if (listener != null) {            listener.editTextValueChanged(event);        }    }        /**    * Implement the DocumentListener interface.    * This method is called when the text changes.    * @param event    		The DocumentEvent    */        public void insertUpdate(DocumentEvent event){        enableEditMenu(activeTextArea, false);        if (listener != null) {            listener.editTextValueChanged(event);        }        }        public void removeUpdate(DocumentEvent event) {        enableEditMenu(activeTextArea, false);        if (listener != null) {            listener.editTextValueChanged(event);        }        }        public void changedUpdate(DocumentEvent event) {        enableEditMenu(activeTextArea, false);        if (listener != null) {            listener.editTextValueChanged(event);        }        }    /**     * Implement the KeyListener interface.     * This method is called when a key is pressed.     * It is unused here.     * @param event             The KeyEvent     */    public void keyPressed(            KeyEvent            event        )    {    }    /**     * Implement the KeyListener interface.     * This method is called when a key is released.     * It is unused here.     * @param event             The KeyEvent     */    public void keyReleased(            KeyEvent            event        )    {    }    /*     * Implement the KeyListener interface.     * A key was typed. Manage Undo and possibly     * update the menus. The other KeyListener     * methods are ignored.     * @param event             The KeyEvent     */    public void keyTyped(            KeyEvent            event        )    {        if (false) {            System.out.println("KeyEvent 0x"                    + Integer.toHexString(event.getKeyChar())                    + " at " + getCaretPosition()                    + ", \"" + getText() + "\""                );        }        saveKeyEventUndoState(event);        enableEditMenu(activeTextArea, false);    }            /*     * Implement the MouseListener interface. This hack watches for     * mouse-up events in the text entry objects, and updates the     * edit menu when needed.     */    /**      * Implement the MouseListener interface. This method is     * called when the mouse is clicked. It is unused here.     * @param event             The MouseEvent     */    public void mouseClicked(            MouseEvent          event        )    {    }    /**      * Implement the MouseListener interface. This method is     * called when the mouse enters the Component. It is unused here.     * @param event             The MouseEvent     */    public void mouseEntered(            MouseEvent          event        )    {    }    /**      * Implement the MouseListener interface. This method is     * called when the mouse leaves the Component. It is unused here.     * @param event             The MouseEvent     */    public void mouseExited(            MouseEvent          event        )    {    }    /**      * Implement the MouseListener interface. This method is     * called when the mouse is pressed in the Component. It is unused here.     * @param event             The MouseEvent     */    public void mousePressed(            MouseEvent          event        )    {    }    /**     * Implement the MouseListener interface. Watch for     * mouse-up events in the text entry objects, and update the     * edit menu when needed. The other MouseListener methods     * are ignored.     * @param event             The MouseEvent     */    public void mouseReleased(            MouseEvent          event        )    {        enableEditMenu(activeTextArea, false);    }    /**     * A key was typed. If it is a content key (letter, number     * or similar), save a "typing" undo. If it is a forward     * or backwards delete, save a "delete" undo.     * @param event             The KeyEvent     */    private void saveKeyEventUndoState(            KeyEvent            event        )    {        // System.out.println("Key 0x" + Integer.toHexString(event.getKeyChar()));        switch (event.getKeyChar()) {        case '\b':              /* "Backspace"                  */        case '\u007F':          /* Forward delete on Mac        */            saveUndoState(EditTextAreaListener.UNDO_DELETE);            break;        default:            saveUndoState(EditTextAreaListener.UNDO_TYPING);            break;        }    }    /**     * Manage the Undo support.     * Start a fresh "undo" activity of the designated kind.     * Note that, when the actual text changes, our textListener     * will call the listener's enableEditMenu.     * param newUndoState       The new state value.     */    private void saveUndoState(            int         newUndoState        )    {        int selectionStart      = getSelectionStart();        int selectionEnd        = getSelectionEnd();        if (newUndoState != undoState         || selectionStart != selectionEnd         || Math.abs(selectionStart - previousSelectionStart) > 1) {            /*             * Start a new Undo action.             */            undoState           = newUndoState;            beforeSelectionStart = selectionStart;            beforeSelectionEnd  = selectionEnd;            undoText            = getText();            undoClipboard       = null;            switch (newUndoState) {            case EditTextAreaListener.UNDO_CUT:            case EditTextAreaListener.UNDO_PASTE:            case EditTextAreaListener.REDO_CUT:            case EditTextAreaListener.REDO_PASTE:                undoClipboard   = getClipboardContents();                break;            default:                break;            }            if (false) {                System.out.println(getUndoMenuItemLabel()                        + ": " + selectionStart                        + ", " + selectionEnd                        + " \"" + undoText + "\""                    );            }        }        previousSelectionStart  = selectionStart;        if (false) {            System.out.println("prefSelStart = " + previousSelectionStart);        }    }        /**     * Kill any pending undo. This is called after e.g. revert     * or File/Open     */    public void killUndo()    {        undoState               = EditTextAreaListener.UNDO_NOTHING;        undoText                = "";        undoClipboard           = null;        enableEditMenu(activeTextArea, true);    }        /**     * Execute the current Undo/Redo action. The menu handler calls     * this when the user choose the Edit/Undo menu item.     */     public void performUndo()    {        if (undoState != EditTextAreaListener.UNDO_NOTHING) {            /*             * If the user was undo-ing, then redo, else undo.             */            undoState   = (undoState <= EditTextAreaListener.UNDO_REPLACE)                        ? undoState + EditTextAreaListener.UNDO_ACTION_COUNT                        : undoState - EditTextAreaListener.UNDO_ACTION_COUNT;            /*             * Exchange the current text with the undo text             */            String currentText  = getText();            int currentSelStart = getSelectionStart();            setText(undoText);            setSelectionStart(beforeSelectionStart);            setSelectionEnd(beforeSelectionEnd);            previousSelectionStart      = currentSelStart;            undoText                    = currentText;            if (false) {                System.out.println(getUndoMenuItemLabel()                        + ": new prevSelStart = " + currentSelStart                        + " \"" + undoText + "\""                    );            }            /*             * If the replacement came from the Clipboard, swap the current             * clipboard with the old clipboard. undoClipboard will be             * non-null if this is a CUT or PASTE action.             */            if (undoClipboard != null) {                try {                    Transferable t      = getClipboardContents();                    if (t != null) {                        Clipboard clip  = getToolkit().getSystemClipboard();                        if (clip != null) {                            clip.setContents(undoClipboard, null);                        }                    }                    undoClipboard       = t;                }                catch (Exception e) {                    System.err.println("Undo clipboard exchange exception: " + e);                }            }            enableEditMenu(activeTextArea, false);      /* Update menus */        }    }    /**     * Store some text in the clipboard.     * @param text              The text to store.     */    private void putClipboard(            String              text        )    {        StringSelection selection       = new StringSelection(text);        try {            Clipboard clip      = getToolkit().getSystemClipboard();            if (clip == null) {                System.err.println("No system clipboard support, sorry.");            }            else {                clip.setContents(selection, null);            }        }        catch (Exception e) {            System.err.println("Put data into clipboard exception: " + e);        }    }    /**     * Retrieve the current clipboard as a string. Return "" if the     * current clipboard is not a atring.     * @return the clipboard text or "" if no string is in the Clipboard.     */    private String getClipboard()    {        String result           = "";        try {            Transferable t      = getClipboardContents();            if (t != null             && t.isDataFlavorSupported(DataFlavor.stringFlavor)) {                result          =                         (String) t.getTransferData(DataFlavor.stringFlavor);            }        }        catch (UnsupportedFlavorException e) { }        catch (IOException e) {} /* No room for the string? */        catch (Exception e) {            System.out.println("Warning: can't get clipboard: " + e.toString());            // e.printStackTrace();        }        return (result);    }    /**     * Check whether there is a String on the Clipboard.     * @param true if there is a String on the clipboard.     */    private boolean isClipboardString()    {        boolean result          = false;        try {            Transferable t      = getClipboardContents();            if (t != null             && t.isDataFlavorSupported(DataFlavor.stringFlavor)) {                result  = true;            }        }        catch (Exception e) {            System.err.println("Exception looking at clipboard: " + e);        }        return (result);    }    /**     * Get the contents of the clipboard.     * @return the Clipboard contents or null if nothing is     * available.     */    private Transferable getClipboardContents()    {        Transferable result     = null;        try {            Clipboard clip      = getToolkit().getSystemClipboard();            if (clip != null) {                result          = clip.getContents(this);            }        }        catch (Exception e) {            System.err.println("Get clipboard exception: " + e);        }        return (result);    }    /**     * Enable and disable the edit menu components.     * @param activeTextArea    The currently-active text area     * @param alwaysNotifyListener True if the listener should be     *          notified even if nothing changed. This is needed     *          for FocusGained and to initialize a new listener.     */    private synchronized void enableEditMenu(            EditTextArea        activeTextArea,            boolean             alwaysNotifyListener        )    {        this.activeTextArea             = activeTextArea;        if (listener != null) {            boolean hasSelection        = false;            boolean hasClipboardContent = false;            if (activeTextArea == this) {                hasSelection            = (getSelectionStart() != getSelectionEnd());                hasClipboardContent     = isClipboardString();            }            if (alwaysNotifyListener             || hasSelection            != currentHasSelection             || hasClipboardContent     != currentHasClipboardContent             || undoState               != currentUndoState) {                currentHasSelection             = hasSelection;                currentHasClipboardContent      = hasClipboardContent;                currentUndoState                = undoState;                listener.enableEditMenu(                        activeTextArea,                        hasSelection,                        hasClipboardContent                    );            }        }    }}
