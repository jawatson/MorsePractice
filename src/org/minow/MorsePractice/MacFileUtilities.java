package org.minow.MorsePractice; import java.util.*;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Method;/* * MacFileUtilities contains several static methods that provide * Macintosh file symantics in an operating-system neutral manner. * They were written using the Java language reflection capability * and can be compiled and run on all Java 1.1 implementations. * * <p> * Copyright &copy; 1999-2000  *      <a href="mailto:minow@pobox.com">Martin Minow</a>. *      All Rights Reserved. * </p> * <p> * <small> * Permission to use, copy, modify, and redistribute this software and its * documentation for personal, non-commercial use is hereby granted provided that * this copyright notice and appropriate documentation appears in all copies. This * software may not be distributed for fee or as part of commercial, "shareware," * and/or not-for-profit endevors including, but not limited to, CD-ROM collections, * online databases, and subscription services without specific license.  The * author makes no expressed or implied warranty of any kind and assumes no * responsibility for errors or omissions. No liability is assumed for any incidental * or consequental damages in connection with or arising out of the use of the * information or program. * </small> * </p> * * @author <a href="mailto:minow@pobox.com">Martin Minow</a> * @version 1.1 * This module is Java 1.1 compatible. */public class MacFileUtilities{    @SuppressWarnings("unchecked")    private static Class<?>        mrjFileUtils                    = null;    private static Class<?>        mrjOSType                       = null;    private static Method       mrjSetFileTypeAndCreator        = null;    private static Constructor<?>  mrjOSTypeConstructor            = null;    private static Method       mrjOSTypeMethodToInt            = null;    private static Method      mrjGetFileTypeMethod            = null;        /*     * This static constructor resolves the Mac-specific classes     * and methods in a 100% pure manner.     */    static {        try {            mrjFileUtils                = Class.forName(                    "com.apple.mrj.MRJFileUtils"                );            mrjOSType                   = Class.forName(                    "com.apple.mrj.MRJOSType"                );            mrjOSTypeConstructor        = mrjOSType.getDeclaredConstructor(                    new Class<?>[] { String.class }                );            mrjOSTypeMethodToInt        = mrjOSType.getDeclaredMethod(                    "toInt",                    new Class<?>[] { }                );            mrjGetFileTypeMethod        = mrjFileUtils.getDeclaredMethod(                    "getFileType",                    new Class<?>[] { java.io.File.class }                );            mrjSetFileTypeAndCreator    = mrjFileUtils.getDeclaredMethod(                         "setFileTypeAndCreator",                         new Class<?>[] {                                    java.io.File.class,                                    mrjOSType,                                    mrjOSType                                }                    );            // System.out.println("Got static initializers");        }        catch (Exception e) {            // e.printStackTrace();     /* Debug only */            mrjFileUtils                = null;            mrjOSType                   = null;            mrjOSTypeConstructor        = null;            mrjSetFileTypeAndCreator    = null;            mrjGetFileTypeMethod        = null;            mrjOSTypeConstructor        = null;        }    }        /**     * When run under MRJ, set the creator and filetype of the     * argument output file. Do nothing if the MRJ file utilities     * are not provided.     * @param out       An FileWriter or FileOutputStream     * @param creator   The creator type string.     * @param fileType  The file type string.     * @throws IOException on file errors.     */    public static void setCreatorAndFileType(            Object              out,            String              creator,            String              fileType        )        throws java.io.IOException    {        try {            Object[] args       = new Object[3];            args[0]             = out;            args[1]             = mrjOSTypeConstructor.newInstance(                                        new Object[] { fileType }                                    );            args[2]             = mrjOSTypeConstructor.newInstance(                                        new Object[] { creator }                                    );            mrjSetFileTypeAndCreator.invoke(null, args);            // System.out.println("mrjSetFileTypeAndCreator success");        }        catch (Exception e) {            if (e instanceof java.io.IOException) {                throw new java.io.IOException(e.getMessage());            }            // e.printStackTrace(); /* Debug only */        }    }        /**     * Check whether the file defined by directory and filename has     * the required fileType. Return true/false if the check can be made.     * Throw an IOException if the file is not found or cannot be examined.     * Throw a ClassNotFoundException if the MRJ classes cannot be loaded or used.     * The caller should catch IOException and report an error to the user.     * The caller should catch ClassNotFoundException and use some other     * mechanism to determine the file type. For example, the calling routine     * might look for a file extension string.     * @param directory         The file directory.     * @param filename          The file name     * @param fileType          The file type ("TEXT", etc).     * @return true if this is the given file.     * @throws IOException on file errors.     * @throws ClassNotFoundException if the MRJ classes are not supported.     */    public static boolean isFileType(            File                directory,            String              filename,            String              fileType        )        throws java.io.IOException,                java.lang.ClassNotFoundException    {        return (isFileType(new File(directory, filename), fileType));    }        /**     * Check whether the file defined by directory and filename has     * the required fileType. Return true/false if the check can be made.     * Throw an IOException if the file is not found or cannot be examined.     * Throw some other exception if the MRJ classes cannot be loaded or used.     * The caller should catch IOException and report an error to the user.     * The caller should catch ClassNotFoundException and use some other     * mechanism to determine the file type. For example, the calling routine     * might look for a file extension string.     * @param file              The file to check..     * @param fileType          The file type ("TEXT", etc).     * @return true if this is the given file.     * @throws IOException on file errors.     * @throws ClassNotFoundException if the MRJ classes are not supported.     */    public static boolean isFileType(            File                file,            String              fileType        )        throws java.io.IOException,                java.lang.ClassNotFoundException    {        boolean result          = false;        try {            int fileTypeValue   = osTypeToInt(fileType);            int testFileType    = getFileType(file);            result              = fileTypeValue == testFileType;        }        catch (Exception e) {            if (e instanceof java.io.IOException) {                throw new java.io.IOException(e.getMessage());            }            throw new java.lang.ClassNotFoundException(e.getMessage());        }        return (result);                        }        /**     * Implement new MRJOSType(fileType). Return zero if the MRJ classes     * are not provided.     * @param argString         A 4-byte creator/filetype string.     * @return the same value as an integer. Return 0 on errors.     */    public static int osTypeToInt(            String              argString        )    {        int result              = 0;        try {            String[] args       = new String[1];            args[0]             = argString;            // System.out.println("osTypeToInt, calling MRJOSType constructor");            Object osType       = mrjOSTypeConstructor.newInstance((Object)args);            // System.out.println("osTypeToInt, calling MRJOSType.toInt()");            Object value        = mrjOSTypeMethodToInt.invoke(                                        osType,                                        new Object[] { }                                    );            result              = ((Integer) value).intValue();            if (false) {                System.out.println("osTypeToInt(\"" + argString                        + "\"): " + Integer.toHexString(result)                    );            }        }        catch (Exception e) {            // e.printStackTrace();        }        return (result);    }        /**     * Return the Macintosh file type as an integer     * @param file              The file     * @return the fileType as an integer. Return zero on errors.     */    public static int getFileType(            File                file        )    {        int result              = 0;        try {            Object osType       = mrjGetFileTypeMethod.invoke(                                        null,                                        new Object[] { file }                                    );            Object value        = mrjOSTypeMethodToInt.invoke(                                        osType,                                        new Object[] { }                                    );            result              = ((Integer) value).intValue();            // System.out.println("getFileType success: " + Integer.toHexString(result));        }        catch (Exception e) {            // e.printStackTrace();        }        return (result);    }}