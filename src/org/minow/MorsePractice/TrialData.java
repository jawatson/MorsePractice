package org.minow.MorsePractice;import java.util.*;
import java.util.TreeMap;
import java.awt.event.*;/** * TrialDialog implements a simple dialog that displays the results of * a MorsePractice training pass. It holds data, but has no display * capability.<p> * * <p> * Copyright &copy; 1999-2000  *      <a href="mailto:minow@pobox.com">Martin Minow</a>. *      All Rights Reserved. * </p> * <p> * <small> * Permission to use, copy, modify, and redistribute this software and its * documentation for personal, non-commercial use is hereby granted provided that * this copyright notice and appropriate documentation appears in all copies. This * software may not be distributed for fee or as part of commercial, "shareware," * and/or not-for-profit endevors including, but not limited to, CD-ROM collections, * online databases, and subscription services without specific license.  The * author makes no expressed or implied warranty of any kind and assumes no * responsibility for errors or omissions. No liability is assumed for any incidental * or consequental damages in connection with or arising out of the use of the * information or program. * </small> * </p> * * @author <a href="mailto:minow@pobox.com">Martin Minow</a> * @version 1.0 */public class TrialData{    /**     * The vector of TrialPairs.     */    public TrialPair[]          trialPair;    /**     * The confusion matrix.     */    public int[][]              matrix          = null;    /**     * The number of times each character was sent.     */    public int[]                sentSum         = null;    /**     * The number of times each character was received.     */    public int[]                gotSum          = null;    /**     * The unique symbols that were sent in sorted order.     */    public TrialChar[]          sentSymbols     = null;    /**     * The unique symbols that the user heard in sortd order.     */    public TrialChar[]          gotSymbols      = null;    /**     * The size of the sentSymbols vector.     */    public int                  sentLength      = 0;    /**     * The size of the gotSymbols vector     */    public int                  gotLength       = 0;    /**     * Convert the confusion matrix that describes this trial.     */    public TrialData(Trial trial) {        try { /* Catch programming errors */            trialPair           = trial.getTrialPairs();            /*             * First, find the unique sent and received characters.             */            int totalSymbols    = trialPair.length;            TreeMap<String, TrialChar> sentTreeMap  = new TreeMap<String, TrialChar>();            TreeMap<String, TrialChar> gotTreeMap   = new TreeMap<String, TrialChar>();            for (int i = 0; i < totalSymbols; i++) {                TrialPair thisPair = trialPair[i];                storeChar(sentTreeMap, thisPair.sentChar);                storeChar(gotTreeMap, thisPair.gotChar);            }            sentSymbols         = sortSymbols(sentTreeMap); /*jw*/            gotSymbols          = sortSymbols(gotTreeMap);  /*jw*/            /*             * Now, construct and populate the confusion matrix.             */            sentLength          = sentSymbols.length;            gotLength           = gotSymbols.length;            matrix              = new int[gotLength][sentLength];            sentSum             = new int[sentLength];            gotSum              = new int[gotLength];            for (int i = 0; i < totalSymbols; i++) {                char sentChar   = trialPair[i].sentChar;                char gotChar    = trialPair[i].gotChar;                int sentIndex   = find(sentChar, sentSymbols);                int gotIndex    = find(gotChar, gotSymbols);                matrix[gotIndex][sentIndex] += trialPair[i].count;                if (false) {                    System.out.println(i + ": " + trialPair[i]                            + ", sentIndex " + sentIndex                            + ", gotIndex " + gotIndex                            + ", sent '" + sentSymbols[sentIndex]                            + "', got '" + gotSymbols[gotIndex] + "'"                        );               }            }            for (int row = 0; row < gotLength; row++) {                int[] vector    = matrix[row];                for (int col = 0; col < sentLength; col++) {                    int value   = vector[col];                    gotSum[row] += value;                    sentSum[col] += value;                }            }        }        catch (Exception e) {            System.out.println(e.toString());            dumpTrialData();            throw new RuntimeException(e.toString());        }    }        /**     * Store a character in the hashtable if it isn't there     * already.     * @param hashTable         The table that will hold unique     *                          character values.     * @param theChar           The value to store.     */    private void storeChar(TreeMap<String, TrialChar> theTreeMap, char theChar){        TrialChar trialChar     = new TrialChar(theChar);        String key              = trialChar.toString();        if (!theTreeMap.containsKey(key)) {            theTreeMap.put(key, trialChar);        }    }        /**     * Convert the TreeMap to an array.     */    private TrialChar[] sortSymbols(TreeMap<String, TrialChar> table) {        /*Comparable[] sorted     = Sort.sort(table);  jw */
        Vector<TrialChar> sorted = new Vector<TrialChar>(table.values());
        TrialChar[] result      = new TrialChar[sorted.size()];        for (int i = 0; i < table.size(); i++) {            result[i]           = sorted.elementAt(i);        }        return (result);
    }    /**     * Find a character in a sorted vector of strings. Return the index of     * the closest match (since we constructed the table with all unique     * characters, it must (!) return the actual match. This is the     * ancient and honorable binary chop lookup routine, taken from equally     * ancient and honorable (and ever so slightly buggy) C code.     * @param value             The value to look for     * @param table             The sorted String[] table.     */    private int find(            char                value,            TrialChar[]         table        )    {        int low                 = 0;        int high                = table.length - 1;        int mid                 = 0;        try {search:     do {                while (low <= high) {                    mid         = low + (high - low) / 2;                    if (value < table[mid].theChar) {                        high    = mid - 1;                    }                    else if (value > table[mid].theChar) {                        low     = mid + 1;                    }                    else {                        break search;                    }                }                if (low >= table.length && table.length > 0) {                    mid         = table.length - 1;                    break search;                }            } while (false);        }        catch (Exception e) { /* Debugging only: probably an unsorted table */            System.out.println("value = '" + value + "'");            System.out.println(" size = " + table.length);            System.out.println("  low = " + low);            System.out.println("  mid = " + mid);            System.out.println(" high = " + high);            for (int i = 0; i < table.length; i++) {                System.out.println(i + ": '" + table[i].theChar + "'");            }            throw new RuntimeException(e.toString());        }        return (mid);    }        /**     * Debug     */    private void dumpTrialData()    {        dumpTrialPair();        dumpSymbols("Sent", sentSymbols);        dumpSymbols(" Got", gotSymbols);        dumpMatrix();        dumpVector("Sent", sentSum);        dumpVector(" Got", gotSum);    }    private void dumpTrialPair()    {        if (trialPair == null) {           System.out.println("null trialPair");        }        else {            System.out.println("TrialPair length = " + trialPair.length);            for (int i = 0; i < trialPair.length; i++) {                System.out.println(i + ": '" + trialPair[i].toString() + "'");            }        }    }    private void dumpSymbols(            String      what,            TrialChar[] vector        )    {        if (vector == null) {            System.out.println("Null " + what + " symbol vector");        }        else {            System.out.println(what + " symbol vector length = " + vector.length);            for (int i = 0; i < vector.length; i++) {                System.out.println(i + ": '" + vector[i].toString() + "'");            }        }    }    private void dumpMatrix()    {        if (matrix == null) {            System.out.println("Null matrix");        }        else {            System.out.println("Matrix length = " + matrix.length);            for (int i = 0; i < matrix.length; i++) {                dumpVector(Integer.toString(i), matrix[i]);            }        }    }    private void dumpVector(            String      what,            int[]       vector        )    {        if (vector == null) {            System.out.println("Null " + what + " vector");        }        else {            System.out.print(what + "[" + vector.length + "]: ");            for (int i = 0; i < vector.length; i++) {                System.out.print(" " + vector[i]);            }            System.out.println();        }   }}
