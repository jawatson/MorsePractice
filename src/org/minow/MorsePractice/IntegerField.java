package org.minow.MorsePractice;import java.util.Locale;import java.awt.Color;import java.awt.Toolkit;import java.text.ParseException;
import java.text.NumberFormat;import javax.swing.event.DocumentListener;import javax.swing.JTextField;import javax.swing.text.AttributeSet;import javax.swing.text.BadLocationException;import javax.swing.text.Document;import javax.swing.text.PlainDocument;/** * IntegerField provides a range-checked data entry area for integers.<p> * * <p> * Copyright &copy; 1999-2000  *      <a href="mailto:minow@pobox.com">Martin Minow</a>. *      All Rights Reserved. * </p> * <p> * <small> * Permission to use, copy, modify, and redistribute this software and its * documentation for personal, non-commercial use is hereby granted provided that * this copyright notice and appropriate documentation appears in all copies. This * software may not be distributed for fee or as part of commercial, "shareware," * and/or not-for-profit endevors including, but not limited to, CD-ROM collections, * online databases, and subscription services without specific license.  The * author makes no expressed or implied warranty of any kind and assumes no * responsibility for errors or omissions. No liability is assumed for any incidental * or consequental damages in connection with or arising out of the use of the * information or program. * </small> * </p> * * @author <a href="mailto:minow@pobox.com">Martin Minow</a> * @version 1.0 * Set tabs every 8 characters. * */  /** * Modified by J.Watson 31/1/03 to use Swing components. */ public class IntegerField extends JTextField {
    public static final long serialVersionUID = 13040901L;    private Toolkit             toolkit;    private NumberFormat        integerFormatter;    private int                 minimum;    private int                 maximum;    private String              myName          = "";    /**     * Create a default IntegerField     */    public IntegerField() {        this(3, 0, 0, 0);    }    /**     * Create an IntegerField with a specific field width.     * @param columns           The field width.     */    public IntegerField(int columns) {        this(columns, 0, 0, 0);    }    /**     * Create an IntegerField with a specific field width     * and initial value.     * @param columns           The field width.     * @param initialValue      The initial field value.     */    public IntegerField(            int                 columns,            int                 initialValue) {        this(columns, initialValue, 0, 0);    }    /**     * Create an IntegerField with a specific field width,     * initial value, minimum and maximum value.     * @param columns           The field width.     * @param initialValue      The initial field value.     * @param minimum           The minimum valid value.     * @param maximum           The maximum valid value.     */    public IntegerField(            int                 columns,            int                 initialValue,            int                 minimum,            int                 maximum) {        super(columns);        this.minimum            = minimum;        this.maximum            = maximum;        setBackground(Color.white);        toolkit                 = Toolkit.getDefaultToolkit();        integerFormatter        =                NumberFormat.getNumberInstance(Locale.getDefault());        integerFormatter.setParseIntegerOnly(true);        setText(Integer.toString(initialValue));    }    /**     * Set the internal name of this field. This lets a caller     * distinguish between several IntegerField objects.     * @param myName    The name of this IntegerField     */    public void setMyName(String myName) {        this.myName = myName;    }    /**     * Return the value of this field. This always returns     * a valid value.     */    public int getValue() {        int retVal = 0;        try {            retVal = integerFormatter.parse(getText()).intValue();        } catch (ParseException e) {            // This should never happen because insertString allows            // only properly formatted data to get in the field.            toolkit.beep();        }        return retVal;    }    /**     * Set the value of this field. This ignores the minimum and     * maximum field values: it is the caller's responsibility to     * respect the limits.     * @param value     The value to set.     */    public void setValue(int value) {        setText(integerFormatter.format(value));    }    /**     * Set the minimum value. This forces the value in range.     * @param minimum   The minimum value.     */    public void setMinimum(            int                 minimum        )    {        this.minimum            = minimum;        if (minimum < maximum && Integer.parseInt(getText()) < minimum) {            String newString    = Integer.toString(minimum);            setText(newString);        }    }    /**     * Return the current minimum value.     * @return  The minimum value.     */    public int getMinimum()    {        return (minimum);    }    /**     * Set the maximum value. This forces the value in range.     * @param maximum   The maximum value.     */    public void setMaximum(int maximum) {        this.maximum            = maximum;        if (minimum < maximum && Integer.parseInt(getText()) > minimum) {            String newString    = Integer.toString(maximum);            setText(newString);        }    }    /**     * Return the current maximum value.     * @return  The maximum value.     */    public int getMaximum() {        return (maximum);    }        /**     * Implement the DocumentListener interface. If the user attempts     * to enter an invalid value, beep and force the string to     * the last valid value.     * @param event     The TextEvent     */        protected Document createDefaultModel() {        return new WholeNumberDocument();    }    protected class WholeNumberDocument extends PlainDocument {
        public static final long serialVersionUID = 13040901L;        public void insertString(int offs,                                  String str,                                 AttributeSet a)                 throws BadLocationException {            char[] source = str.toCharArray();            char[] result = new char[source.length];            int j = 0;            for (int i = 0; i < result.length; i++) {                if (Character.isDigit(source[i]))                    result[j++] = source[i];                else {                    toolkit.beep();                    System.err.println("insertString: " + source[i]);                }            }            super.insertString(offs, new String(result, 0, j), a);        }    }}
