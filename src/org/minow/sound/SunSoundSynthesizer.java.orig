package org.minow.sound;import java.util.*;import java.net.*;import java.io.*;/* * sun.audio is not guaranteed to work on all Java implementations. * This import generates a warning that has been suppressed with 
 * the @SuppressWarnings( "all" ) in the class declaration. 
  */import sun.audio.*;/** * SunSoundSynthesizer synthesizes .au format audio data, * <p> * This module only works with the sun.audio.* classes, and does * not work on Window systems running Java 1.3. * </p> * <p> * Copyright &copy; 1999-2000  *      <a href="mailto:minow@pobox.com">Martin Minow</a>. *      All Rights Reserved. * </p> * <p> * <small> * Permission to use, copy, modify, and redistribute this software and its * documentation for personal, non-commercial use is hereby granted provided that * this copyright notice and appropriate documentation appears in all copies. This * software may not be distributed for fee or as part of commercial, "shareware," * and/or not-for-profit endevors including, but not limited to, CD-ROM collections, * online databases, and subscription services without specific license.  The * author makes no expressed or implied warranty of any kind and assumes no * responsibility for errors or omissions. No liability is assumed for any incidental * or consequental damages in connection with or arising out of the use of the * information or program. * </small> * </p> * * @author <a href="mailto:minow@pobox.com">Martin Minow</a> * @version 1.2 * This module is Java 1.1 compatible. */
@SuppressWarnings( "all" ) public class SunSoundSynthesizer extends SoundSynthesizerParent        implements  org.minow.sound.Sound,                    java.applet.AudioClip,                    Runnable{    /*     * AMPLITUDE converts between volume (range -1.0 to 1.0) and the actual value     * to be synthesized.     */    public static final float AMPLITUDE                 = (float) (32768.0 * DEFAULT_AMPLITUDE);    public static final int SAMPLES_PER_SECOND          = 8000;    private Thread runner           = null;    public SunSoundSynthesizer()    {        super();        setSynthesizerFrequency(DEFAULT_SYNTHESIZER_FREQUENCY);    }    public final int getSamplesPerSecond()    {        return (SAMPLES_PER_SECOND);    }        /**     * Append a single sample to the current synthesis.     * This is normally called by the tone() and silence()     * methods.     * @param sample    The amplitude of the value to synthesize.     *                  This should be a value between 0.0 and 1.0     */    public void synthesize(            float           sample        )    {        int value           = (int) (sample * AMPLITUDE);        write(ULAW.linearToULaw(value));    }    /**     * Append a vector of samples to the current synthesis.     * This is normally called by the tone() and silence()     * methods.     * @param samples   Each element of the samples vector contains     *                  am amplitude of the value to synthesize.     *                  This should be a value between 0.0 and 1.0     * @param offset    The starting point in the samples vector     * @param length    The number of samples to synthesize     */    public void synthesize(            float[]     samples,            int         offset,            int         length        )    {        byte[] data     = new byte[length];        for (int i = 0; i < length; i++) {            int value   = (int) (samples[i + offset] * AMPLITUDE);            data[i]     = ULAW.linearToULaw(value);        }        try {            write(data);        }        catch (IOException ignore) {}    }    /*     * Stop any current synthesis and get ready to start a new     * sound. This will signal listeners that synthesis is now active.     */    public void startSynthesizer()    {        play(); /* java.applet.AudioClip */    }    /**     * Stop any current synthesis. This will signal listeners that     * synthesis is no longer active.     */    public void stopSynthesizer()    {        stop(); /* java.applet.AudioClip */    }    /**      * Inform the caller whether the synthesis is active.     * @return true if the synthesizer is making a sound.     */    public synchronized boolean isSynthesizerActive()    {        return (runner != null && runner.isAlive());    }    /**     * Write the current synthesis to an audio file. The file     * will always be written in Sun .au (ULAW) format. Clients     * can use the Sound.ULAW methods to write the header and     * convert data from linear to ULAW format.     */    public void writeAudio(            DataOutputStream    out        )        throws IOException    {        ULAW.writeAudioHeader(                out,                size(),                SAMPLES_PER_SECOND            );        /*         * Since our data is already in uLaw, we don't have         * to do any additional conversion.         */        writeTo(out);    }    /**     * Implement the AudioClip interface. Note that loop is not implemented.     */    public synchronized void loop()    {        throw new RuntimeException("loop not supported");    }    /**     * Implement the AudioClip interface. Stop any current synthesis and     * start a new sound. This will signal listeners that synthesis is active.     */    public synchronized void play()    {        stop();        if (runner == null || runner.isAlive() == false) {            runner          = new Thread(this);            signalListeners(true);            runner.start();        }    }    /**     * Implement the AudioClip interface. Stop any current synthesis.     * This will signal listeners that synthesis is not active.     */    public synchronized void stop()    {        if (runner != null && runner.isAlive()) {            runner.interrupt();        }        runner              = null;    }    /**     * Implement the Runnable interface.     */    public void run()    {        AudioDataStream audioDataStream     = null;        // System.out.println("AudioSequence playing " + size() + " bytes");        long duration                       = 0;        try {            /*             * All of the sun.audio code is in this module: convert the             * byte array to an audio object and start playing it. Then,             * sleep for the expected duration and kill the audio when             * the sounds have completed.             */            AudioData audioData             = new AudioData(toByteArray());            audioDataStream                 = new AudioDataStream(audioData);            duration                        = getDuration();            AudioPlayer.player.start(audioDataStream);            Thread.sleep(duration);        }        catch (IllegalArgumentException e) {            System.out.println("Bogus duration " + duration);            e.printStackTrace();        }        catch (InterruptedException ignore) {            // System.out.println("AudioSequence interrupted");        }        catch (Exception e) {            if (e instanceof ClassNotFoundException) {                System.err.println("This Java implementation does not support the sun.audio classes");                System.err.println("Please exit the program.");            }            else {                e.printStackTrace();            }        }        finally {            if (audioDataStream != null) {                try {                    AudioPlayer.player.stop(audioDataStream);                }                catch (Exception e) {}            }            audioDataStream     = null;        }        signalListeners(false);    }        }
