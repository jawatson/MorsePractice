package org.minow.sound;import java.util.*;import java.net.*;import java.io.*;/* * javax.sound is not guaranteed to work on all Java implementations. */import javax.sound.sampled.*;/** * JavaxSynthesizer synthesizes .au format audio data, using * org.minow.audio.SoundSynthesizerData for the underlying audio * sequence. It uses the javax.sound classes * <p> * This module only works with the javax.sound classes and has * only been tested on Windows/98 running Java 1.3. * </p> * <p> * Copyright &copy; 1999-2000  *      <a href="mailto:minow@pobox.com">Martin Minow</a>. *      All Rights Reserved. * </p> * <p> * <small> * Permission to use, copy, modify, and redistribute this software and its * documentation for personal, non-commercial use is hereby granted provided that * this copyright notice and appropriate documentation appears in all copies. This * software may not be distributed for fee or as part of commercial, "shareware," * and/or not-for-profit endevors including, but not limited to, CD-ROM collections, * online databases, and subscription services without specific license.  The * author makes no expressed or implied warranty of any kind and assumes no * responsibility for errors or omissions. No liability is assumed for any incidental * or consequental damages in connection with or arising out of the use of the * information or program. * </small> * </p> * * @author <a href="mailto:minow@pobox.com">Martin Minow</a> * @version 1.2 * This module is Java 1.1 compatible. */public class JavaxSoundSynthesizer extends SoundSynthesizerParent        implements org.minow.sound.Sound,                    javax.sound.sampled.LineListener{    /*     * AMPLITUDE converts between volume (range -1.0 to 1.0) and the actual value     * to be synthesized.     */    public static final float AMPLITUDE         = (float) (128.0 * DEFAULT_AMPLITUDE);    private JavaxSynthesizer synthesizer;        /**     * This should fail if the javax.sun classes are not available.     */    public JavaxSoundSynthesizer()        throws ClassNotFoundException    {        try {            synthesizer     = new JavaxSynthesizer(this);            setSynthesizerFrequency(DEFAULT_SYNTHESIZER_FREQUENCY);        }        catch (Exception e) {            e.printStackTrace();            throw new ClassNotFoundException(e.toString());        }    }    /**     * Return the number of samples per second     */    public final int getSamplesPerSecond()    {        return (synthesizer.getSamplesPerSecond());    }    /**     * Append a single sample to the current synthesis.     * This is normally called by the tone() and silence()     * methods.     * @param sample    The amplitude of the value to synthesize.     *                  This should be a value between 0.0 and 1.0     */    public void synthesize(            float           sample        )    {        write((int) (sample * AMPLITUDE));    }    /**     * Append a vector of samples to the current synthesis.     * This is normally called by the tone() and silence()     * methods.     * @param samples   Each element of the samples vector contains     *                  am amplitude of the value to synthesize.     *                  This should be a value between 0.0 and 1.0     * @param offset    The starting point in the samples vector     * @param length    The number of samples to synthesize     */    public void synthesize(            float[]     samples,            int         offset,            int         length        )    {        byte[] data     = new byte[length];        for (int i = 0; i < length; i++) {            data[i]     = (byte) (samples[i + offset] * AMPLITUDE);        }        try {            write(data);        }        catch (IOException ignore) {            ignore.printStackTrace();        }    }    /*     * Stop any current synthesis and get ready to start a new     * sound. This will signal listeners that synthesis is now active.     */    public void startSynthesizer()    {        synthesizer.startSynthesis(toByteArray());    }    /**     * Stop any current synthesis. This will signal listeners that     * synthesis is no longer active.     */    public synchronized void stopSynthesizer()    {        synthesizer.stopSynthesis();    }    /**      * Inform the caller whether the synthesis is active.     * @return true if the synthesizer is making a sound.     */    public synchronized boolean isSynthesizerActive()    {        return (synthesizer.isSynthesizerActive());    }    /**     * Write the current synthesis to an audio file. The file     * will always be written in Sun .au (ULAW) format. Clients     * can use the Sound.ULAW methods to write the header and     * convert data from linear to ULAW format.     */    public void writeAudio(            DataOutputStream    out        )        throws IOException    {        ULAW.writeAudioHeader(                out,                size(),                SAMPLES_PER_SECOND            );        byte[] data         = toByteArray();        /*         * Convert from linear to uLaw         */        for (int i = 0; i < data.length; i++) {            int linear      = (data[i] & 0xFF) - 128;            data[i]         = ULAW.linearToULaw(linear);        }        out.write(data);    }     /*     * Implement the javax.sound.LineListener interface.     */    public void update(            LineEvent       event        )    {        LineEvent.Type type = event.getType();        // System.out.println("LineListener.update: " + type.toString());        if (type == LineEvent.Type.START) {            signalListeners(true);        }        else if (type == LineEvent.Type.STOP) {            signalListeners(false);        }        else { /* Ignore */ }    }}