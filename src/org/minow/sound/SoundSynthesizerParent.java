package org.minow.sound;import java.util.*;import java.net.*;import java.io.*;/* * sun.audio is not guaranteed to work on all Java implementations. * This import generates a warning that has been suppressed with  * the @SuppressWarnings( "all" ) in the class declaration.  */  import sun.audio.*;/** * SunSoundSynthesizer synthesizes .au format audio data, * <p> * This module only works with the sun.audio.* classes, and does * not work on Window systems running Java 1.3. * </p> * <p> * Copyright &copy; 1999-2000  *      <a href="mailto:minow@pobox.com">Martin Minow</a>. *      All Rights Reserved. * </p> * <p> * <small> * Permission to use, copy, modify, and redistribute this software and its * documentation for personal, non-commercial use is hereby granted provided that * this copyright notice and appropriate documentation appears in all copies. This * software may not be distributed for fee or as part of commercial, "shareware," * and/or not-for-profit endevors including, but not limited to, CD-ROM collections, * online databases, and subscription services without specific license.  The * author makes no expressed or implied warranty of any kind and assumes no * responsibility for errors or omissions. No liability is assumed for any incidental * or consequental damages in connection with or arising out of the use of the * information or program. * </small> * </p> * * @author <a href="mailto:minow@pobox.com">Martin Minow</a> * @version 1.2 * This module is Java 1.1 compatible. */
public abstract class SoundSynthesizerParent extends ByteArrayOutputStream        implements  org.minow.sound.Sound{    public static final int SAMPLES_PER_SECOND  = 8000;    public static final int AMPLITUDE           = (int) (DEFAULT_AMPLITUDE * 32768.0);    public static final int RAMP_SAMPLES        = ((SAMPLES_PER_SECOND * RAMP_DURATION_MILLIS) / 1000);    private Vector<Sound.Listener> listeners    = new Vector<Sound.Listener>();    private double synthesizerFrequency;    protected double frequencyFactor;    public SoundSynthesizerParent()    {        super();    }    /**     * Add a Sound.Listener that will be notified when we start     * or stop the music.     * @param listener an Object that implements Sound.Listener      */    public final void addListener(            Sound.Listener      listener        )    {        listeners.addElement(listener);    }            /**     * Remove a Sound.Listener     * @param listener an Object that implements Sound.Listener      */    public void removeListener(            Sound.Listener      listener        )    {        listeners.removeElement(listener);    }    /*     * Accessors for the sound synthesize frequency.     */        /**     * Return the current synthesizer frequency.     * @return the current synthesizer frequency.     */    public double getSynthesizerFrequency()    {        return (synthesizerFrequency);    }    /**     * Set the synthesizer frequency.     * @param synthesizerFrequency  The new synthesizer frequency.     */    public void setSynthesizerFrequency(            double          synthesizerFrequency        )    {        this.synthesizerFrequency = synthesizerFrequency;        frequencyFactor     = synthesizerFrequency * TWO_PI / getSamplesPerSecond();    }    /**     * Return the number of samples per second.     */    public abstract int getSamplesPerSecond();        /*     * These methods generate sounds (and silence).     */            /**     * Append a one-second "tick" to the current synthesis.     * @throws IOException     */    public void tick()    {        tone(20);        silence(900);    }    /**     * Append a silent sequence to the current synthesis.     * @param durationMillis    The duration in milliseconds.     * @throws IOException     */    public void silence(            int             durationMillis        )    {        synthesize(getSampleVector(durationMillis));    }        /**     * Append a tone at the default amplitude to the current     * synthesis. Note that the tone will ramp up and down to     * avoid clicks.     * @param durationMillis    The duration in milliseconds.     * @throws IOException     */    public void tone(            int             durationMillis        )    {        float[] samples     = getSampleVector(durationMillis);        int nSamples        = samples.length;        int rampSamples     = (getSamplesPerSecond() * RAMP_DURATION_MILLIS) / 1000;        nSamples            -= rampSamples;     /* Leave room for ramp down */        /*         * Smooth both edges of the signal for 5 msec to avoid ticks.         */        for (int i = 0; i < samples.length; i++) {            double volume   = 0.0;            if (i < rampSamples) {                volume      = ((double) i) / ((double) rampSamples);            }            else if (i < nSamples) {                volume      = 1.0;            }            else {                volume      = ((double) (samples.length - i - 1)) / ((double) rampSamples);            }            samples[i]      = (float) (volume * Math.sin(i * frequencyFactor));        }        synthesize(samples);    }        private final float[] getSampleVector(            int             durationMillis        )    {        int nSamples        = (durationMillis * getSamplesPerSecond()) / 1000;        float[] samples     = new float[nSamples];  /* Zero value by default */        return (samples);    }    /**     * Return the estimated duration of the current sequence     * in milliseconds     * @return the duration in milliseconds     * @throws IOException     */    public long getDuration()    {        return ((((long) size()) * 1000) / getSamplesPerSecond());    }    /**     * Reset the synthesizer for a new sequence. This also     * stops synthesis if active.     * @throws IOException     */    public void resetSynthesizer()    {        super.reset();    }    /**     * Append a single sample to the current synthesis.     * This is normally called by the tone() and silence()     * methods.     * @param sample    The amplitude of the value to synthesize.     *                  This should be a value between -1.0 and 1.0     */    public abstract void synthesize(            float           sample        );    /**     * Append a vector of samples to the current synthesis.     * This is normally called by the tone() and silence()     * methods.     * @param samples   Each element of the samples vector contains     *                  am amplitude of the value to synthesize.     *                  This should be a value between -1.0 and 1.0     */    public void synthesize(            float[]     samples        )    {        synthesize(samples, 0, samples.length);    }    /**     * Append a vector of samples to the current synthesis.     * This is normally called by the tone() and silence()     * methods.     * @param samples   Each element of the samples vector contains     *                  am amplitude of the value to synthesize.     *                  This should be a value between -1.0 and 1.0     * @param offset    The starting point in the samples vector     * @param length    The number of samples to synthesize     */    public void synthesize(            float[]     samples,            int         offset,            int         length        )    {        for (int i = 0; i < length; i++) {            synthesize(samples[i + offset]);        }    }    /**     * Signal any interested listeners.     * @param active        True if the synthesizer is now running.     */    protected void signalListeners(boolean active)    {        Vector<Sound.Listener> clone;        synchronized (this) {            //clone = (Vector<Listener>) listeners.clone();
            clone = new Vector<Listener>(listeners);        }        Enumeration<Sound.Listener> e = clone.elements();        while (e.hasMoreElements()) {            Sound.Listener target = e.nextElement();            target.soundSynthesis(active);        }    }}